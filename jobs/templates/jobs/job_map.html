{% extends 'base.html' %}
{% load static %}
{% block content %}
<div class="container my-4">
  <h1 class="mb-3">Jobs Near Me</h1>
  <div id="map" style="height: 520px; border-radius: 12px;"></div>
  <p class="text-muted mt-2">Showing {{ jobs|length }} job(s) with coordinates.</p>
</div>

<link rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script>
(function () {
  console.log("[map] init");
  const map = L.map('map').setView([33.7490, -84.3880], 12); // ATL default
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

  // Layer groups
  const jobsLayer = L.layerGroup().addTo(map);
  let hereMarker = null;

  function markHere(lat, lng) {
    if (hereMarker) map.removeLayer(hereMarker);
    hereMarker = L.marker([lat, lng]).addTo(map).bindPopup('You are here');
  }

  // Add markers from GeoJSON-ish object
  function renderJobs(data) {
    console.log("[map] renderJobs raw:", data);
    const feats = Array.isArray(data?.features) ? data.features
                : Array.isArray(data?.jobs) ? data.jobs     // tolerate alternate shape
                : [];
    jobsLayer.clearLayers();
    const pts = [];

    feats.forEach(f => {
      // Accept either Feature or plain object with lat/lng
      let lat, lng, props = {};
      if (f?.geometry?.coordinates) {
        const [lngRaw, latRaw] = f.geometry.coordinates;
        lat = Number(latRaw);
        lng = Number(lngRaw);
        props = f.properties || {};
      } else if (f?.lat && f?.lng) {
        lat = Number(f.lat);
        lng = Number(f.lng);
        props = f;
      }
      if (Number.isFinite(lat) && Number.isFinite(lng)) {
        const m = L.marker([lat, lng]).bindPopup(
          `<b>${props.title || ''}</b><br>${props.company || ''}<br>${props.location || ''}` +
          (props.detail_url ? `<br><a href="${props.detail_url}">View</a>` : '')
        );
        jobsLayer.addLayer(m);
        pts.push([lat, lng]);
      }
    });

    console.log("[map] markers placed:", pts.length);
    if (pts.length) map.fitBounds(L.latLngBounds(pts), { padding: [20, 20] });
    if (!pts.length) console.warn("[map] No job features to render");
  }

  // Fetch helper with loud logging
  function fetchJSON(url) {
    console.log("[map] fetching:", url);
    return fetch(url, { credentials: 'same-origin' })
      .then(r => {
        console.log("[map] response", r.status, r.url);
        if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
        return r.json();
      });
  }

  // Use your nearby endpoint
  function loadNearby(lat, lng, radiusKm) {
    const url = `/api/jobs/?lat=${lat}&lng=${lng}&radius_km=${radiusKm}`;
    return fetchJSON(url).then(renderJobs).catch(err => {
      console.error("[map] nearby error:", err);
      alert("Couldn't load nearby jobs â€” see console.");
    });
  }

  // Start: geolocate or fallback; then load jobs
  const defaultCenter = [33.7490, -84.3880];
  const defaultRadius = 50;

  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      pos => {
        const lat = pos.coords.latitude, lng = pos.coords.longitude;
        map.setView([lat, lng], 13);
        markHere(lat, lng);
        loadNearby(lat, lng, defaultRadius);
      },
      () => {
        const [lat, lng] = defaultCenter;
        map.setView([lat, lng], 12);
        markHere(lat, lng);
        loadNearby(lat, lng, defaultRadius);
      },
      { enableHighAccuracy: true, timeout: 8000 }
    );
  } else {
    const [lat, lng] = defaultCenter;
    map.setView([lat, lng], 12);
    markHere(lat, lng);
    loadNearby(lat, lng, defaultRadius);
  }
})();
</script>



{% endblock %}
